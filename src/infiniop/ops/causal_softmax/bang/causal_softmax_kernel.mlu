#include "../../../devices/bang/common_bang.h"

__nram__ char nram_buffer[NRAM_MAX_SIZE];

template <typename Tdata, typename Tcompute>
__mlu_global__ void causalSoftmax(
    Tdata *y, const Tdata *x,
    uint32_t batch, uint32_t height, uint32_t width,
    ptrdiff_t y_stride_b, ptrdiff_t y_stride_i, ptrdiff_t y_stride_j,
    ptrdiff_t x_stride_b, ptrdiff_t x_stride_i, ptrdiff_t x_stride_j) {

    const int total_tasks = int(batch) * int(height);
    int remainT = total_tasks % taskDim;
    int stepEasy = (total_tasks - remainT) / taskDim;
    int stepHard = stepEasy + 1;
    int step = (taskId < remainT ? stepHard : stepEasy);
    int indStart = (taskId < remainT ? taskId * stepHard : (taskId - remainT) * stepEasy + remainT * stepHard);

    char *aligned_nram_base = (char *)(((size_t)nram_buffer + ALIGN_SIZE - 1) & ~(ALIGN_SIZE - 1));
    size_t nram_usable = NRAM_MAX_SIZE - (size_t)(aligned_nram_base - nram_buffer) - ALIGN_SIZE;
    const int wSize = 128 / sizeof(float);

    int chunk_target = (int)(nram_usable / (sizeof(Tdata) + sizeof(float) + 256));
    if (chunk_target < 16) {
        chunk_target = 16;
    }

    const int META_LIMIT = 256;
    float meta_max[META_LIMIT];
    float meta_sum[META_LIMIT];

    for (int t = 0; t < step; ++t) {
        int task_idx = indStart + t;
        int batch_idx = task_idx / int(height);
        int row = task_idx % int(height);

        ptrdiff_t y_base = ptrdiff_t(batch_idx) * y_stride_b + ptrdiff_t(row) * y_stride_i;
        ptrdiff_t x_base = ptrdiff_t(batch_idx) * x_stride_b + ptrdiff_t(row) * x_stride_i;

        int valid_len = int(width) - int(height) + 1 + row;
        if (valid_len < 0) {
            valid_len = 0;
        }
        if (valid_len > int(width)) {
            valid_len = int(width);
        }

        if (valid_len == 0) {
            __nram__ Tdata z;
            z = (Tdata)0;
            for (int c = 0; c < (int)width; ++c) {
                __memcpy(y + y_base + ptrdiff_t(c) * y_stride_j, &z, sizeof(Tdata), NRAM2GDRAM);
            }
            continue;
        }

        int chunk_elems = chunk_target;
        if (chunk_elems > valid_len) {
            chunk_elems = valid_len;
        }
        if (chunk_elems <= 0) {
            chunk_elems = 1;
        }

        char *nram_base = aligned_nram_base;
        Tdata *nram_src = (Tdata *)nram_base;
        float *nram_f = (float *)(nram_base + ((size_t)chunk_elems * sizeof(Tdata) + 127) / 128 * 128);

        // PASS A: compute max and sums
        int processed = 0;
        int meta_count = 0;
        while (processed < valid_len) {
            int cur = (valid_len - processed) < chunk_elems ? (valid_len - processed) : chunk_elems;

            if (x_stride_j == 1) {
                __memcpy(nram_src, x + x_base + ptrdiff_t(processed), cur * sizeof(Tdata), GDRAM2NRAM);
            } else {
                for (int i = 0; i < cur; ++i) {
                    __memcpy((char *)nram_src + i * sizeof(Tdata),
                             x + x_base + ptrdiff_t(processed + i) * x_stride_j,
                             sizeof(Tdata), GDRAM2NRAM);
                }
            }

            if constexpr (std::is_same<Tdata, float>::value) {
                float maxv = -INFINITY;
                for (int i = 0; i < cur; ++i) {
                    float vv = nram_src[i];
                    if (vv > maxv) {
                        maxv = vv;
                    }
                }
                // sum of exp(x - maxv)
                float s = 0.0f;
                for (int i = 0; i < cur; ++i) {
                    float vv = nram_src[i];
                    float e = expf(vv - maxv);
                    s += e;
                }
                if (meta_count < META_LIMIT) {
                    meta_max[meta_count] = maxv;
                    meta_sum[meta_count] = s;
                    ++meta_count;
                } else {
                    float M0 = meta_max[0], S0 = meta_sum[0];
                    float M1 = maxv, S1 = s;
                    if (M1 > M0) {
                        meta_sum[0] = S1 + S0 * expf(M0 - M1);
                        meta_max[0] = M1;
                    } else {
                        meta_sum[0] = S0 + S1 * expf(M1 - M0);
                    }
                    meta_count = 1;
                }
            } else {
                for (int i = 0; i < cur; ++i) {
                    nram_f[i] = (float)(nram_src[i]);
                }
                __nram__ float srcMaxTmp[2];
                __bang_argmax(srcMaxTmp, nram_f, cur);
                float chunk_max = srcMaxTmp[0];

                __bang_sub_scalar(nram_f, nram_f, chunk_max, cur);
                __bang_active_exp_less_0(nram_f, nram_f, cur);

                float chunk_sum = 0.0f;
                if (cur >= wSize) {
                    int segNum = cur / wSize;
                    for (int strip = segNum / 2; strip > 0; strip = strip / 2) {
                        for (int j = 0; j < strip; ++j) {
                            __bang_add(nram_f + j * wSize, nram_f + j * wSize, nram_f + (j + strip) * wSize, wSize);
                        }
                    }
                    __nram__ float destSumFinal[128];
                    __bang_reduce_sum(destSumFinal, nram_f, wSize);
                    chunk_sum = destSumFinal[0];
                } else {
                    __nram__ float destSumFinal[128];
                    __bang_write_zero(destSumFinal, wSize);
                    __memcpy(destSumFinal, nram_f, cur * sizeof(float), NRAM2NRAM);
                    __bang_reduce_sum(destSumFinal, destSumFinal, wSize);
                    chunk_sum = destSumFinal[0];
                }

                if (meta_count < META_LIMIT) {
                    meta_max[meta_count] = chunk_max;
                    meta_sum[meta_count] = chunk_sum;
                    ++meta_count;
                } else {
                    float M0 = meta_max[0], S0 = meta_sum[0];
                    float M1 = chunk_max, S1 = chunk_sum;
                    if (M1 > M0) {
                        meta_sum[0] = S1 + S0 * expf(M0 - M1);
                        meta_max[0] = M1;
                    } else {
                        meta_sum[0] = S0 + S1 * expf(M1 - M0);
                    }
                    meta_count = 1;
                }
            }

            processed += cur;
        } // end

        // merge meta -> globalMax & totalSum
        float globalMax = meta_max[0];
        float totalSum = meta_sum[0];
        for (int m = 1; m < meta_count; ++m) {
            float mm = meta_max[m], ss = meta_sum[m];
            if (mm > globalMax) {
                totalSum = ss + totalSum * expf(globalMax - mm);
                globalMax = mm;
            } else {
                totalSum = totalSum + ss * expf(mm - globalMax);
            }
        }

        // PASS B: compute normalized exp and write final once
        processed = 0;
        float inv_total = 1.0f / (totalSum + 1e-20f);
        while (processed < valid_len) {
            int cur = (valid_len - processed) < chunk_elems ? (valid_len - processed) : chunk_elems;

            if (x_stride_j == 1) {
                __memcpy(nram_src, x + x_base + ptrdiff_t(processed), cur * sizeof(Tdata), GDRAM2NRAM);
            } else {
                for (int i = 0; i < cur; ++i) {
                    __memcpy((char *)nram_src + i * sizeof(Tdata),
                             x + x_base + ptrdiff_t(processed + i) * x_stride_j,
                             sizeof(Tdata), GDRAM2NRAM);
                }
            }

            if constexpr (std::is_same<Tdata, float>::value) {
                if (y_stride_j == 1) {
                    // contiguous write
                    for (int i = 0; i < cur; ++i) {
                        float vv = nram_src[i];
                        __nram__ float outv;
                        outv = expf(vv - globalMax) * inv_total;
                        __memcpy(y + y_base + ptrdiff_t(processed + i), &outv, sizeof(float), NRAM2GDRAM);
                    }
                } else {
                    for (int i = 0; i < cur; ++i) {
                        float vv = nram_src[i];
                        __nram__ float outv;
                        outv = expf(vv - globalMax) * inv_total;
                        __memcpy(y + y_base + ptrdiff_t(processed + i) * y_stride_j, &outv, sizeof(float), NRAM2GDRAM);
                    }
                }
            } else {
                for (int i = 0; i < cur; ++i) {
                    nram_f[i] = (float)(nram_src[i]);
                }
                __bang_sub_scalar(nram_f, nram_f, globalMax, cur);
                __bang_active_exp_less_0(nram_f, nram_f, cur);
                __bang_mul_scalar(nram_f, nram_f, inv_total, cur);

                for (int i = 0; i < cur; ++i) {
                    __nram__ Tdata outv;
                    outv = (Tdata)(nram_f[i]);
                    if (y_stride_j == 1) {
                        __memcpy(y + y_base + ptrdiff_t(processed + i), &outv, sizeof(Tdata), NRAM2GDRAM);
                    } else {
                        __memcpy(y + y_base + ptrdiff_t(processed + i) * y_stride_j, &outv, sizeof(Tdata), NRAM2GDRAM);
                    }
                }
            }

            processed += cur;
        } // end

        if (valid_len < int(width)) {
            __nram__ Tdata z;
            z = (Tdata)0;
            for (int c = valid_len; c < int(width); ++c) {
                __memcpy(y + y_base + ptrdiff_t(c) * y_stride_j, &z, sizeof(Tdata), NRAM2GDRAM);
            }
        }
    }
}
